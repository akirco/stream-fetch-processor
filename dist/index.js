var p=Object.defineProperty;var u=(o,e,r)=>e in o?p(o,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):o[e]=r;var a=(o,e,r)=>(u(o,typeof e!="symbol"?e+"":e,r),r);var c=class{constructor(e={}){a(this,"decoder");a(this,"reader");a(this,"controller");a(this,"response",null);this.decoder=e.decoder??new TextDecoder("utf-8"),this.controller=new AbortController,this.reader=null}async fetch(e,r,n=3){try{let t=await fetch(e,{...r,signal:this.controller.signal});if(!t.ok)throw new Error(`Response error: ${t.status} ${t.statusText}`);return t.ok&&(this.response=t),t}catch(t){if(n>0)return this.fetch(e,r,n-1);throw new Error(`Failed to fetch: ${t}`)}}async parserReader(e){let r=this.decoder;async function*n(l){for(;!l.done;){if(l.done)return console.log("SSE connection closed by server"),Promise.resolve();let d=r.decode(l.value,{stream:!0}).split(`
`).filter(s=>s!==""&&s!==" ");for(let s=0;s<d.length;s++){let i=d[s].trim();if(i.length===0)continue;yield i.split("data: ").filter(h=>h!==""&&h!==" ")[0]}l=await e.read()}}let t=await e.read();return n(t)}async read(e){if(!this.response&&!e)throw new Error("No response available");try{if(this.reader=(e??this.response)?.body?.getReader(),this.reader)return this.parserReader(this.reader);throw new Error("No reader available")}catch(r){throw this.reader?.cancel(),new Error(`Failed to read: ${r}`)}}cancel(){this.reader?.cancel(),this.controller.abort()}};export{c as default};
