var c=Object.defineProperty;var i=(o,e,r)=>e in o?c(o,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):o[e]=r;var s=(o,e,r)=>(i(o,typeof e!="symbol"?e+"":e,r),r);var n=class{constructor(e={}){s(this,"decoder");s(this,"fetchFn");s(this,"reader");s(this,"controller");s(this,"response",null);if(typeof window.fetch!="function")throw new Error("fetch method is not available");this.decoder=e.decoder??new TextDecoder("utf-8"),this.controller=new AbortController,this.fetchFn=window.fetch,this.reader=null}async fetch(e,r={},a=3){try{let t=await this.fetchFn(e,{...r,signal:this.controller.signal});if(!t.ok)throw new Error(`Response error: ${t.status} ${t.statusText}`);return t.ok&&(this.response=t),t}catch(t){if(a>0)return console.log(`Failed to fetch ${e}, retrying (${a} retries left)...`),this.fetch(e,r,a-1);throw new Error(`Failed to fetch: ${t}`)}}async read(e){if(!this.response&&!e)throw new Error("No response available");try{if(this.reader=(e??this.response)?.body?.getReader(),this.reader){let{done:r,value:a}=await this.reader.read(),t=this.decoder.decode(a);return{done:r,value:t}}else return{done:!0,value:""}}catch(r){throw this.reader?.cancel(),new Error(`Failed to read: ${r}`)}finally{this.reader?.releaseLock(),this.response?.body?.cancel(),e?.body?.cancel()}}cancel(){this.reader?.cancel(),this.controller.abort()}};export{n as default};
